import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';

import '../../api/home_api.dart';
import '../../../auth/controller/auth_provider.dart';
import '../../model/home_provider.dart';
import '../../../bottom_nav/view/bottom_nav_screen.dart';
import 'module_apply.dart';

class PhotoRecordScreen extends ConsumerStatefulWidget {
  const PhotoRecordScreen({super.key});

  @override
  ConsumerState<PhotoRecordScreen> createState() => _PhotoRecordScreenState();
}

class _PhotoRecordScreenState extends ConsumerState<PhotoRecordScreen> {
  final TextEditingController _titleController = TextEditingController();
  final TextEditingController _contentController = TextEditingController();

  final _imagePicker = ImagePicker();
  List<XFile> _selectedImages = [];

  String? selectedFriend;
  String? selectedLocation;
  String? selectedEmotion;
  String? selectedCategory;
  String? selectedRecordType;
  DateTime selectedDate = DateTime.now();

  @override
  void initState() {
    super.initState();
    _pickImages();
  }

  Future<void> _pickImages() async {
    try {
      final List<XFile> images = await _imagePicker.pickMultiImage();
      if (images.isNotEmpty) {
        setState(() {
          _selectedImages = images;
        });
      }
    } catch (e) {
      debugPrint('Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù Ï§ë Ïò§Î•ò Î∞úÏÉù: $e');
    }
  }

  Future<void> _showPickerModal({
    required String title,
    required List<String> items,
    required ValueChanged<String> onSelected,
    required String category,
  }) async {
    final result = await showModalBottomSheet<String>(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return _SearchablePickerModal(
          title: title,
          items: items,
          onSelected: (value) {
            // Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú ÏòµÏÖòÏù∏ÏßÄ ÌôïÏù∏
            final recordOptions = ref.read(recordOptionsProvider);
            if (recordOptions.hasValue) {
              final options = recordOptions.value!;
              if (options[category]!.contains(value)) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏòµÏÖòÏûÖÎãàÎã§.')),
                );
                return;
              }
            }
            Navigator.pop(context, value);
          },
          category: category,
        );
      },
    );

    if (result != null) {
      onSelected(result);
    }
  }

  Widget _buildSelector({
    required IconData icon,
    required String? selectedValue,
    required String defaultLabel,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12),
        child: Row(
          children: [
            Icon(icon, color: Colors.black),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                selectedValue ?? defaultLabel,
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime(2100),
    );
    if (picked != null && picked != selectedDate) {
      setState(() => selectedDate = picked);
    }
  }

  Future<void> _submitRecord() async {
  final userId = ref.read(authProvider).userId;
  debugPrint('[DEBUG] üë§ Ïú†Ï†Ä ID: $userId');

  if (userId == null) {
    if (!mounted) return;
    debugPrint('[DEBUG] ‚ùå Ïú†Ï†Ä ID ÏóÜÏùå. Î°úÍ∑∏Ïù∏ ÌïÑÏöî!');
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.')),
    );
    return;
  }

  if (_titleController.text.isEmpty ||
      _contentController.text.isEmpty ||
      _selectedImages.isEmpty) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Ï†úÎ™©, ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÍ≥† Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')),
    );
    return;
  }

    // ÏÑ†ÌÉùÎêú ÏòµÏÖò Ï†ÄÏû•
    final recordOptions = ref.read(recordOptionsProvider);
    if (recordOptions.hasValue) {
      final options = recordOptions.value!;
      try {
        if (selectedFriend != null && !options['friends']!.contains(selectedFriend)) {
          await HomeApi.addOption(userId, 'friends', selectedFriend!);
        }
        if (selectedLocation != null && !options['locations']!.contains(selectedLocation)) {
          await HomeApi.addOption(userId, 'locations', selectedLocation!);
        }
        if (selectedEmotion != null && !options['emotions']!.contains(selectedEmotion)) {
          await HomeApi.addOption(userId, 'emotions', selectedEmotion!);
        }
        if (selectedCategory != null && !options['categories']!.contains(selectedCategory)) {
          await HomeApi.addOption(userId, 'categories', selectedCategory!);
        }
        if (selectedRecordType != null && !options['recordTypes']!.contains(selectedRecordType)) {
          await HomeApi.addOption(userId, 'recordTypes', selectedRecordType!);
        }
      } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏòµÏÖòÏûÖÎãàÎã§.')),
        );
        return;
      }
    }

  final recordData = {
    'title': _titleController.text,
    'content': _contentController.text,
      'friend': selectedFriend,
      'location': selectedLocation,
      'emotion': selectedEmotion,
      'category': selectedCategory,
      'recordType': selectedRecordType,
    'date': selectedDate.toIso8601String(),
    'type': 'photo',
  };

  debugPrint('[DEBUG] üìù Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞: $recordData');

  try {
    final success = await HomeApi.postRecord(userId, recordData, _selectedImages);
    debugPrint('[DEBUG] üì° postRecord Í≤∞Í≥º: $success');

    if (!mounted) return;

    if (success) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Í∏∞Î°ùÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!')),
      );
        ref.invalidate(homeProvider);
        ref.invalidate(recordOptionsProvider); // ÏòµÏÖò Î™©Î°ù Í∞±Ïã†
        Navigator.pushAndRemoveUntil(
          context,
          MaterialPageRoute(builder: (context) => const BottomNavScreen()),
          (route) => false,
        );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Í∏∞Î°ù Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')),
      );
    }
  } catch (e) {
    debugPrint('[ERROR] üß® ÏòàÏô∏ Î∞úÏÉù: $e');
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Í∏∞Î°ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏñ¥Ïöî.')),
    );
  }
}

  @override
  Widget build(BuildContext context) {
    final recordOptions = ref.watch(recordOptionsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Ïù¥ÎØ∏ÏßÄ Í∏∞Î°ù'),
        actions: [
          TextButton(
            onPressed: () {
              if (_titleController.text.isEmpty ||
                  _contentController.text.isEmpty ||
                  _selectedImages.isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Ï†úÎ™©, ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÍ≥† Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')),
                );
                return;
              }

              final recordData = {
                'title': _titleController.text,
                'content': _contentController.text,
                'friend': selectedFriend,
                'location': selectedLocation,
                'emotion': selectedEmotion,
                'category': selectedCategory,
                'recordType': selectedRecordType,
                'date': selectedDate.toIso8601String(),
                'type': 'photo',
              };

              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => ModuleApplyScreen(
                    recordData: recordData,
                    images: _selectedImages,
                  ),
                ),
              );
            },
            child: const Text('Îã§Ïùå'),
          ),
        ],
      ),
      body: recordOptions.when(
        data: (options) => SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Ïù¥ÎØ∏ÏßÄ ÎØ∏Î¶¨Î≥¥Í∏∞
            if (_selectedImages.isNotEmpty)
              Container(
                height: 200,
                margin: const EdgeInsets.only(bottom: 16),
                child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  itemCount: _selectedImages.length,
                  itemBuilder: (context, index) {
                    return Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: Image.file(
                        File(_selectedImages[index].path),
                        width: 200,
                        height: 200,
                        fit: BoxFit.cover,
                      ),
                    );
                  },
                ),
              ),
            
            // Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù Î≤ÑÌäº
            ElevatedButton.icon(
              onPressed: _pickImages,
              icon: const Icon(Icons.add_photo_alternate),
              label: const Text('Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù'),
            ),
            const SizedBox(height: 16),

            TextField(
              controller: _titleController,
              decoration: const InputDecoration(
                labelText: 'Ï†úÎ™©',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _contentController,
              decoration: const InputDecoration(
                labelText: 'ÎÇ¥Ïö©',
                border: OutlineInputBorder(),
              ),
              maxLines: 5,
            ),
            const SizedBox(height: 16),

              _buildSelector(
                icon: Icons.person_add_alt_1,
                selectedValue: selectedFriend,
                defaultLabel: 'ÏÇ¨Îûå Ï∂îÍ∞Ä',
                onTap: () => _showPickerModal(
                  title: 'Í¥ÄÍ≥Ñ ÏÑ†ÌÉù',
                  items: options['friends'] ?? [],
                  onSelected: (val) => setState(() => selectedFriend = val),
                  category: 'friends',
                ),
              ),

              _buildSelector(
                icon: Icons.location_on_outlined,
                selectedValue: selectedLocation,
                defaultLabel: 'ÏúÑÏπò Ï∂îÍ∞Ä',
                onTap: () => _showPickerModal(
                  title: 'ÏúÑÏπò ÏÑ†ÌÉù',
                  items: options['locations'] ?? [],
                  onSelected: (val) => setState(() => selectedLocation = val),
                  category: 'locations',
                ),
              ),

              _buildSelector(
                icon: Icons.mood,
                selectedValue: selectedEmotion,
                defaultLabel: 'Í∞êÏ†ï ÏÑ†ÌÉù',
                onTap: () => _showPickerModal(
                  title: 'Í∞êÏ†ï ÏÑ†ÌÉù',
                  items: options['emotions'] ?? [],
                  onSelected: (val) => setState(() => selectedEmotion = val),
                  category: 'emotions',
                ),
              ),

              _buildSelector(
                icon: Icons.category_outlined,
                selectedValue: selectedCategory,
                defaultLabel: 'Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù',
                onTap: () => _showPickerModal(
                  title: 'Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù',
                  items: options['categories'] ?? [],
                  onSelected: (val) => setState(() => selectedCategory = val),
                  category: 'categories',
                ),
              ),

              _buildSelector(
                icon: Icons.label,
                selectedValue: selectedRecordType,
                defaultLabel: 'Í∏∞Î°ù ÌÉÄÏûÖ ÏÑ†ÌÉù',
                onTap: () => _showPickerModal(
                  title: 'Í∏∞Î°ù ÌÉÄÏûÖ',
                  items: options['recordTypes'] ?? [],
                  onSelected: (val) => setState(() => selectedRecordType = val),
                  category: 'recordTypes',
                ),
              ),

              const SizedBox(height: 12),
              _buildSelector(
                icon: Icons.calendar_today,
                selectedValue:
                    '${selectedDate.year}.${selectedDate.month}.${selectedDate.day}',
                defaultLabel: 'ÎÇ†Ïßú ÏÑ†ÌÉù',
                onTap: _selectDate,
              ),
            ],
          ),
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Text('Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: $error'),
        ),
      ),
    );
  }
}

class _SearchablePickerModal extends StatefulWidget {
  final String title;
  final List<String> items;
  final ValueChanged<String> onSelected;
  final String category;

  const _SearchablePickerModal({
    required this.title,
    required this.items,
    required this.onSelected,
    required this.category,
  });

  @override
  State<_SearchablePickerModal> createState() => _SearchablePickerModalState();
}

class _SearchablePickerModalState extends State<_SearchablePickerModal> {
  final TextEditingController _customInputController = TextEditingController();
  String _searchQuery = '';
  List<String> _filteredItems = [];
  List<String> _newItems = [];

  @override
  void initState() {
    super.initState();
    _filteredItems = widget.items;
  }

  void _filterItems(String query) {
    setState(() {
      _searchQuery = query;
      _filteredItems = widget.items
          .where((item) => item.toLowerCase().contains(query.toLowerCase()))
          .toList();
    });
  }

  void _handleCustomInput() {
    if (_customInputController.text.isNotEmpty) {
      // Ï§ëÎ≥µ Ï≤¥ÌÅ¨
      if (widget.items.contains(_customInputController.text)) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏòµÏÖòÏûÖÎãàÎã§.')),
        );
        return;
      }
      setState(() {
        _newItems.add(_customInputController.text);
        _filteredItems.add(_customInputController.text);
      });
      _customInputController.clear();
    }
  }

  @override
  void dispose() {
    _customInputController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                widget.title,
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.add_circle_outline),
                onPressed: () {
                  showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: Text('${widget.title} Ï∂îÍ∞Ä'),
                      content: TextField(
                        controller: _customInputController,
                        decoration: const InputDecoration(
                          hintText: 'ÏÉàÎ°úÏö¥ Ìï≠Î™©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî',
                        ),
                        onSubmitted: (_) {
                          // Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                          if (widget.items.contains(_customInputController.text)) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(content: Text('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏòµÏÖòÏûÖÎãàÎã§.')),
                            );
                            return;
                          }
                          _handleCustomInput();
                          Navigator.pop(context);
                        },
                      ),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.pop(context),
                          child: const Text('Ï∑®ÏÜå'),
                        ),
                        TextButton(
                          onPressed: () {
                            // Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                            if (widget.items.contains(_customInputController.text)) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(content: Text('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏòµÏÖòÏûÖÎãàÎã§.')),
                              );
                              return;
                            }
                            _handleCustomInput();
                            Navigator.pop(context);
                          },
                          child: const Text('Ï∂îÍ∞Ä'),
                        ),
                      ],
                    ),
                  );
                },
            ),
          ],
        ),
          const SizedBox(height: 16),
          TextField(
            controller: _customInputController,
            decoration: InputDecoration(
              hintText: 'ÏßÅÏ†ë ÏûÖÎ†•ÌïòÍ±∞ÎÇò Í≤ÄÏÉâÌïòÏÑ∏Ïöî',
              prefixIcon: const Icon(Icons.search),
              suffixIcon: _customInputController.text.isNotEmpty
                  ? IconButton(
                      icon: const Icon(Icons.check),
                      onPressed: () {
                        // Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                        if (widget.items.contains(_customInputController.text)) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏòµÏÖòÏûÖÎãàÎã§.')),
                          );
                          return;
                        }
                        _handleCustomInput();
                      },
                    )
                  : null,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            onChanged: _filterItems,
          ),
          const SizedBox(height: 16),
          Flexible(
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: _filteredItems.length,
              itemBuilder: (context, index) {
                final item = _filteredItems[index];
                final isNew = _newItems.contains(item);
                return ListTile(
                  title: Text(item),
                  trailing: isNew ? const Icon(Icons.new_releases, color: Colors.blue) : null,
                  onTap: () => Navigator.pop(context, item),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
